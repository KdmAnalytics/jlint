\documentclass[11pt,twoside,a4paper,draft]{article}
\author{Raphael Ackermann raphy@student.ethz.ch}
\title{Jlint}
\begin{document}
\maketitle
\tableofcontents

\section {Jlint}

Jlint is a static model checker for java programs. \newline
URL: http://www.artho.com/jlint/ \newline
http://www.sf.org/jlint/ 


\subsection {Test Framework}

\paragraph
A small test framework was added to jlint to allow testing the behaviour of the program. The test framework consists of a sample of class files together with the output that jlint generates when run on these files. The sample class files are chosen to cover most of jlints possible outcomes. To produce this output jlint version 3.0 was used and the output generated was stored in *.out files. These *.out files represent the reference output which should be matched by all future versions of jlint unless one changes something in the logic of jlint. Whenever there will be changes in the source code of jlint, the test framework should be used to make sure that the output of the new version is the same as the reference output. To run the test framework you need to go into the test/ directory, where you run ./testall.sh.


Testall.sh itself calls runtest.sh, show\-diff.sh and showerror.sh.
\\\\runtest.sh
runs jlint on the sample java class files and writes its output into the *.log and its error messages into *.err.
\\\\showdiff.sh
compares the *.out generated by runtest.sh with the stored *.log files and in case of a difference makes a diff x.{out,log}
\\\\showerror.sh
looks for *.err file with size bigger than 0 and produces a warning and the name of the file if this happens.
should not produce any output if nothing goes wrong. Only in the case that jlint crashes, it reports which files caused jlint to abort.
\\


Adding new test cases to the test framework is quite simple. A new directory eg. test5 has to be created and the classfiles to be tested have to be in that directory. in the file testall.sh the variable NROFTESTS which is currently set to 4 has to be changed to reflect the new number of test cases. First of all a new reference file eg. 5.out has to be created and put into tests/log/ .One has to be careful to use a fully functional/bugfree version of jlint to produce a new reference *.out file. Once this is done testall.sh can be called and will run the tests including the newly added ones.

The tests are all blackbox tests, meaning that jlint is run on some sample input and the output is compared to the reference output. It is not tested how jlint does something. This could be done by using unit testing, which is not beeing done yet, but could be implemented in a future version of the test framework.
Another use of the test framework is the possibility to check whether the same version of jlint produces the same output on different computer architectures. For example the Mac has a different memory alignment and could therefore show other errors than on a windows architecture.



\begin{verbatim}

Test Framework (added in Version 3.0)
=====================================

File locations
--------------
class files to be tested        tests/test#/
log and reference output files  tests/log/

Tests:
------
4 tests as of Version 3.0
test1 test.java
test2 class showing finally bug
test3 sample from java/io/* (1.3)
test4 sample from java/io/* (1.4)

                                    in case of
                                    error:
#           default         run     run
#test 1     log/1.out       1.log   1.err
#test 2     log/2.out       2.log   2.err
#test 3     log/3.out       3.log   3.err
#test 4     log/4.out       4.log   4.err
...

Usage:
------

* To run testsuite using valgrind, 
	try "./testall.sh --valgrind

* For info on how to run tests, 
	try "./testall.sh --help"

\end{verbatim}






\subsection {Found Errors , Bug Fixes}

\subsubsection {Context Handling in Jlint}

\paragraph
Beginning with Java version 1.4.0 the the exception handling mechanismus for try--finally and 
try--catch--finally constructs was changed. Until Java 1.3 there was only one exception handler
for the whole try block. Since 1.4.0 the handled range is split into subranges which are all handled
by the same exception handler. Certain instructions which cannot throw an exception anyway are excluded from the range. eg. the ``ret'' and ``jsr'' instructions. This is done as a workaround in the compiler for a bug in the java virtual machine.

example:
\begin{verbatim}
java/beans/SimpleBeanInfo.class

Exception handler(s) =
From    To    Handler    Type
-0    40    40    java.lang.Exception(9)	//java 1.3
+0    27    40    java.lang.Exception(9)	//java 1.4	
+28    39    40    java.lang.Exception(9)	//java 1.4
\end{verbatim}


\subsubsection {Classes of errors found}

\begin{verbatim}
1st kind of error eg. in:
/java/io/BufferedReader.class
in file:    method_desc.cc
in method:  parse_code(constant **, const field_desc *)
	 Assertion `sp == stack_bottom' failed.
Aborted

2nd kind of error eg. in:
/java/lang/FloatingDecimal.class
in file:    local_context.cc
in method:  transfer(...):
	 Assertion `sp == come_from->stack_pointer' failed.
Aborted 
\end{verbatim}

\subsubsection {Minimal class file that reproduced the bug}

\begin{verbatim}
class SC {
void m(boolean b) {
    try {
        if (b) return;
    } catch (Exception e) {
        b = true;
    } finally {
        b = false;
    }
}
\end{verbatim}

\subsubsection {Bugfix}

The following code was added to jlint.cc to fix the bug.

\begin{verbatim}

	/*  add new entry for exception-handles.It is expected
	** that the handles are ordered. Only one handle for 
	** every byte code adress. eg: in the following example only 
	** add entries at position 16 and 25 . 
	** from         to         handle
	**  2           10           16
	** 12           14           16
	** 20           23           25
	*/

	int old_handler_pc = -1;

        while (--exception_table_length >= 0) { 
          int handler_pc = unpack2(fp+4);
	  if ( handler_pc != old_handler_pc) {
	    new ctx_entry_point(&method->context[handler_pc]); 
	  }
	  fp += 8;
	  old_handler_pc = handler_pc;
        }

\end{verbatim}


\subsection {Changes of the Build Process}

A new and automated build process was implemented during this semester thesis. Before, there was a makefile which one had to change from hand if one wanted to change some architecture specific flags. Of if one wanted a debugging build or a build for a different target machine. The dependencies are automatically generated using a perl script: mkmf.pl. I added a configure script which calculates the options and sets environment variables depending on the OS and does various other things. This configure script generates the makefile. Or better said: it takes a standard Makefile.in and replaces the unspecified options by values it calculates.

The new target test\_dist was added to the makefile. ''make test\_dist'' builds a tar.gz of the sources including the test directory with all the testfiles. It is intended to be used by future developers of jlint to be able to check for errors.


\end{document}

